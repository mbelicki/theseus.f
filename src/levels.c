#include <SDL/SDL.h>

#include "levels.h"
#include "generator.h"

//    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
//    };

#define SPAWNER_V_ENEMY -5
#define SPAWNER_H_ENEMY -6

#define $ TILE_WALL
#define T TILE_TRAP
#define S TILE_TRADER
#define B TILE_BOSS
#define _ TILE_FLOOR
#define v SPAWNER_V_ENEMY
#define h SPAWNER_H_ENEMY

static TileType hello[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, T, _, $, _, _, _, $, _, $, _, _, _, $ 
    , $, _, $, _, _, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, _, $, T, T, _, $, $, $, _, $, _, $, $, $, _, $ 
    , $, _, _, _, T, _, _, _, _, _, $, _, _, $, _, v, $ 
    , $, $, $, _, $, T, T, T, _, $, $, $, _, $, $, _, $ 
    , $, _, h, _, _, _, _, T, _, _, _, $, _, _, _, _, $ 
    , $, $, $, $, $, $, _, $, $, $, _, $, $, $, $, _, $ 
    , _, _, _, _, _, $, _, _, _, $, _, T, $, v, T, _, _ 
    , $, $, $, $, _, $, $, $, _, $, _, T, T, _, $, _, $ 
    , $, _, h, _, _, _, _, $, _, $, _, _, _, _, $, _, $ 
    , $, $, $, $, $, $, _, T, _, T, T, T, $, _, $, _, $ 
    , $, _, _, _, _, _, _, T, _, _, _, _, $, _, $, _, $ 
    , $, _, T, T, T, T, T, $, $, $, $, _, $, _, _, _, $ 
    , $, _, T, _, _, _, T, _, _, _, $, _, $, _, $, _, $ 
    , $, _, _, _, T, _, _, _, $, _, _, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType floor_is_lava[] =
    { T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T
    , T, _, _, _, _, _, T, _, T, _, T, _, _, _, T, _, T 
    , T, _, T, T, T, _, T, v, T, _, T, _, T, _, T, _, T 
    , T, _, T, _, _, _, T, _, _, _, T, _, T, _, T, _, T 
    , T, _, T, _, T, T, T, _, T, _, _, _, T, _, T, _, T 
    , T, _, T, _, T, v, T, _, T, T, T, T, T, _, T, _, $ 
    , T, _, T, _, T, _, T, _, T, _, _, _, _, _, _, h, $ 
    , T, _, T, _, T, _, _, _, T, _, T, T, T, $, $, $, $ 
    , _, _, T, _, _, _, T, _, T, _, _, _, S, _, _, _, _ 
    , T, _, T, _, T, _, _, _, T, _, T, T, T, $, $, $, $ 
    , T, _, T, _, T, _, T, _, T, h, _, _, _, _, _, _, $ 
    , T, _, T, _, T, _, T, _, T, T, T, T, T, _, T, _, T 
    , T, _, T, _, T, T, T, _, T, _, _, _, T, _, T, _, T 
    , T, _, T, _, _, _, T, _, _, _, T, _, T, _, T, _, T 
    , T, _, T, T, T, _, T, _, T, _, T, _, T, _, T, _, T 
    , T, _, _, _, _, _, T, v, T, _, T, _, _, _, T, _, T 
    , T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T 
    };

static TileType mutual_core[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, v, $, _, _, _, T, _, _, _, T, _, _, _, $, v, $ 
    , $, _, $, _, _, _, T, _, _, _, T, _, _, _, $, _, $ 
    , $, _, $, $, $, _, T, _, _, _, T, _, $, $, $, _, $ 
    , $, _, $, v, $, _, T, _, _, _, T, _, $, v, $, _, $ 
    , $, _, _, _, $, $, $, _, _, _, $, $, $, _, $, _, $ 
    , $, _, $, _, $, v, $, $, $, $, $, v, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, T, _, $, _, $, _, $, _, $ 
    , _, _, $, _, _, _, _, _, S, _, _, _, _, _, $, _, _ 
    , $, _, $, _, $, _, $, _, T, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, $, $, _, _, _, $, $, $, _, _, _, $ 
    , $, _, $, _, $, _, T, _, _, _, T, _, $, _, $, _, $ 
    , $, _, $, $, $, _, T, _, _, _, T, _, $, $, $, _, $ 
    , $, _, $, _, _, _, T, _, _, _, T, _, _, _, $, _, $ 
    , $, v, $, _, _, _, T, _, _, _, T, _, _, _, $, v, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType mess[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, $, _, _, _, $, _, _, $, _, _, _, _, $ 
    , $, _, $, _, $, $, $, _, $, _, $, $, _, $, $, $, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, _, _, _, _, $ 
    , $, _, $, _, _, _, $, _, _, _, $, _, $, $, $, $, $ 
    , $, _, $, $, $, $, $, _, $, _, $, _, _, _, _, _, $ 
    , $, _, _, _, _, $, _, _, $, v, $, _, $, $, _, $, $ 
    , $, _, $, $, $, $, $, $, $, _, $, $, $, _, _, _, $ 
    , _, v, T, _, _, h, _, _, T, _, _, _, T, _, T, _, _ 
    , $, _, $, $, $, $, $, _, $, _, $, _, $, _, $, $, $ 
    , $, _, $, _, _, _, $, _, _, _, $, _, $, _, _, _, $ 
    , $, _, $, _, $, _, $, _, $, $, $, _, $, $, _, $, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, _, _, _, _, $ 
    , $, _, _, _, $, v, $, $, $, _, $, $, _, $, $, _, $ 
    , $, _, $, _, $, _, $, _, _, _, $, _, _, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType sliders[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, $, $, $, $, $, $, $, $, _, $, $, $ 
    , $, _, $, h, _, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, _, $, T, $, T, $, T, $, $, $, $, $ 
    , $, _, $, _, h, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, $, $, T, $, T, $, T, $, _, $, $, $ 
    , $, _, $, _, _, h, _, _, _, _, _, _, _, _, $, _, $ 
    , _, _, $, $, $, $, $, _, $, $, $, $, $, $, $, _, _ 
    , $, T, $, _, _, _, $, _, $, _, _, _, $, S, _, _, $ 
    , $, _, $, _, $, _, $, _, _, _, $, $, $, _, $, $, $ 
    , $, _, $, _, $, _, _, _, $, $, $, _, _, _, _, _, $ 
    , $, _, $, _, $, _, $, _, _, _, _, v, $, $, $, $, $ 
    , $, _, $, _, $, _, $, T, $, T, $, _, $, _, _, _, $ 
    , $, _, _, _, $, _, $, _, $, _, $, _, _, _, $, _, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType arena[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, _, _, _, _, _, _, h, _, _, _, _, _, $ 
    , $, _, $, T, $, _, $, $, $, $, $, _, $, T, $, _, $ 
    , $, _, $, _, _, _, h, _, _, _, h, _, _, _, $, _, $ 
    , $, _, $, _, $, $, $, $, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , _, _, $, _, $, _, $, _, B, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, _, _, _, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, $, $, $, $, _, $, _, $ 
    , $, _, $, _, _, _, h, _, _, _, h, _, _, _, $, _, $ 
    , $, v, $, T, $, _, $, $, $, $, $, _, $, T, $, v, $ 
    , $, _, _, _, _, _, h, _, _, _, _, _, _, _, _, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

#undef $
#undef T
#undef S
#undef B
#undef _
#undef v
#undef h

static void find_enemies(State * const state)
{
    int e = 0;

#define MAP_AT(x, y)\
    (state->map.data[(x) + state->map.width * (y)])

    for ( int i = 0; i < state->map.width; i++ ) {
        for ( int j = 0; j < state->map.height; j++ ) {
            const int tile = MAP_AT(i, j);
            if ( tile == SPAWNER_V_ENEMY ) {
                Enemy enemy; init_enemy( &enemy, i, j );
                state->map_enemies[e] = enemy;
                MAP_AT(i, j) = TILE_FLOOR;
                e++;
            } else if ( tile == SPAWNER_H_ENEMY ) {
                Enemy enemy; init_enemy( &enemy, i, j );
                enemy.flags |= ENEMY_MOVING_HORIZONTAL;
                state->map_enemies[e] = enemy;
                MAP_AT(i, j) = TILE_FLOOR;
                e++;
            }

            if (e == MAX_ENEMY_COUNT) break;
        }
    }
#undef MAP_AT

    state->map_enemy_count = e;
}

#define RANDOM_BETWEEN 1

static TileType *pick_nonrandom(const int level)
{
    const int k = level / (RANDOM_BETWEEN + 1);
    switch (k) {
        case 0:  return mess; 
        case 1:  return hello;
        case 2:  return sliders; 
        case 3:  return mutual_core; 
        case 4:  return floor_is_lava; 
        default: return arena; 
    }
}

void change_level( State * const state
                 , Assets * const assets
                 , const int level
                 )
{
    if (state->map.data != NULL && state->map.flags & MAP_DYNAMIC) {
        free(state->map.data);
    }
        
    state->map.width  = 17;
    state->map.height = 17;
    const size_t map_size = state->map.width * state->map.height;

    if (level % (RANDOM_BETWEEN + 1) == 1) {
        state->map.data = pick_nonrandom(level);
        state->map.flags = 0;
    } else {
        state->map.flags = MAP_DYNAMIC;
        state->map.data = malloc(sizeof(TileType) * map_size);
        if (state->map.data == NULL) return;

        fill_with_maze(state->map.data, state->map.width, state->map.height);
    }
    
    find_enemies(state);

    state->current_level_no = level;
}
