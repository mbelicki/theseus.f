#include "map/levels.h"
#include "entity.h"

//    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
//    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
//    };

#define SPAWNER_V_ENEMY -5
#define SPAWNER_H_ENEMY -6

#define $ TILE_WALL
#define T TILE_TRAP
#define S TILE_TRADER
#define B TILE_BOSS
#define _ TILE_FLOOR
#define v SPAWNER_V_ENEMY
#define h SPAWNER_H_ENEMY

static TileType hello[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, T, _, $, _, _, _, $, _, $, _, _, _, $ 
    , $, _, $, _, _, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, _, $, T, T, _, $, $, $, _, $, _, $, $, $, _, $ 
    , $, _, _, _, T, _, _, _, _, _, $, _, _, $, _, v, $ 
    , $, $, $, _, $, T, T, T, _, $, $, $, _, $, $, _, $ 
    , $, _, h, _, _, _, _, T, _, _, _, $, _, _, _, _, $ 
    , $, $, $, $, $, $, _, $, $, $, _, $, $, $, $, _, $ 
    , _, _, _, _, _, $, _, _, _, $, _, T, $, v, T, _, _ 
    , $, $, $, $, _, $, $, $, _, $, _, T, T, _, $, _, $ 
    , $, _, h, _, _, _, _, $, _, $, _, _, _, _, $, _, $ 
    , $, $, $, $, $, $, _, T, _, T, T, T, $, _, $, _, $ 
    , $, _, _, _, _, _, _, T, _, _, _, _, $, _, $, _, $ 
    , $, _, T, T, T, T, T, $, $, $, $, _, $, _, _, _, $ 
    , $, _, T, _, _, _, T, _, _, _, $, _, $, _, $, _, $ 
    , $, _, _, _, T, _, _, _, $, _, _, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType floor_is_lava[] =
    { T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T
    , T, _, _, _, _, _, T, _, T, _, T, _, _, _, T, _, T 
    , T, _, T, T, T, _, T, v, T, _, T, _, T, _, T, _, T 
    , T, _, T, _, _, _, T, _, _, _, T, _, T, _, T, _, T 
    , T, _, T, _, T, T, T, _, T, _, _, _, T, _, T, _, T 
    , T, _, T, _, T, v, T, _, T, T, T, T, T, _, T, _, $ 
    , T, _, T, _, T, _, T, _, T, _, _, _, _, _, _, h, $ 
    , T, _, T, _, T, _, _, _, T, _, T, T, T, $, $, $, $ 
    , _, _, T, _, _, _, T, _, T, _, _, _, S, _, _, _, _ 
    , T, _, T, _, T, _, _, _, T, _, T, T, T, $, $, $, $ 
    , T, _, T, _, T, _, T, _, T, h, _, _, _, _, _, _, $ 
    , T, _, T, _, T, _, T, _, T, T, T, T, T, _, T, _, T 
    , T, _, T, _, T, T, T, _, T, _, _, _, T, _, T, _, T 
    , T, _, T, _, _, _, T, _, _, _, T, _, T, _, T, _, T 
    , T, _, T, T, T, _, T, _, T, _, T, _, T, _, T, _, T 
    , T, _, _, _, _, _, T, v, T, _, T, _, _, _, T, _, T 
    , T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T 
    };

static TileType mutual_core[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, v, $, _, _, _, T, _, _, _, T, _, _, _, $, v, $ 
    , $, _, $, _, _, _, T, _, _, _, T, _, _, _, $, _, $ 
    , $, _, $, $, $, _, T, _, _, _, T, _, $, $, $, _, $ 
    , $, _, $, v, $, _, T, _, _, _, T, _, $, v, $, _, $ 
    , $, _, _, _, $, $, $, _, _, _, $, $, $, _, $, _, $ 
    , $, _, $, _, $, v, $, $, $, $, $, v, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, T, _, $, _, $, _, $, _, $ 
    , _, _, $, _, _, _, _, _, S, _, _, _, _, _, $, _, _ 
    , $, _, $, _, $, _, $, _, T, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, $, $, _, _, _, $, $, $, _, _, _, $ 
    , $, _, $, _, $, _, T, _, _, _, T, _, $, _, $, _, $ 
    , $, _, $, $, $, _, T, _, _, _, T, _, $, $, $, _, $ 
    , $, _, $, _, _, _, T, _, _, _, T, _, _, _, $, _, $ 
    , $, v, $, _, _, _, T, _, _, _, T, _, _, _, $, v, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType mess[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, $, _, _, _, $, _, _, $, _, _, _, _, $ 
    , $, _, $, _, $, $, $, _, $, _, $, $, _, $, $, $, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, _, _, _, _, $ 
    , $, _, $, _, _, _, $, _, _, _, $, _, $, $, $, $, $ 
    , $, _, $, $, $, $, $, _, $, _, $, _, _, _, _, _, $ 
    , $, _, _, _, _, $, _, _, $, v, $, _, $, $, _, $, $ 
    , $, _, $, $, $, $, $, $, $, _, $, $, $, _, _, _, $ 
    , _, v, T, _, _, h, _, _, T, _, _, _, T, _, T, _, _ 
    , $, _, $, $, $, $, $, _, $, _, $, _, $, _, $, $, $ 
    , $, _, $, _, _, _, $, _, _, _, $, _, $, _, _, _, $ 
    , $, _, $, _, $, _, $, _, $, $, $, _, $, $, _, $, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, _, _, _, _, $ 
    , $, _, _, _, $, v, $, $, $, _, $, $, _, $, $, _, $ 
    , $, _, $, _, $, _, $, _, _, _, $, _, _, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType sliders[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, $, $, $, $, $, $, $, $, _, $, $, $ 
    , $, _, $, h, _, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, _, $, T, $, T, $, T, $, $, $, $, $ 
    , $, _, $, _, h, _, _, _, _, _, _, _, _, _, _, _, $ 
    , $, _, $, $, $, $, $, T, $, T, $, T, $, _, $, $, $ 
    , $, _, $, _, _, h, _, _, _, _, _, _, _, _, $, _, $ 
    , _, _, $, $, $, $, $, _, $, $, $, $, $, $, $, _, _ 
    , $, T, $, _, _, _, $, _, $, _, _, _, $, S, _, _, $ 
    , $, _, $, _, $, _, $, _, _, _, $, $, $, _, $, $, $ 
    , $, _, $, _, $, _, _, _, $, $, $, _, _, _, _, _, $ 
    , $, _, $, _, $, _, $, _, _, _, _, v, $, $, $, $, $ 
    , $, _, $, _, $, _, $, T, $, T, $, _, $, _, _, _, $ 
    , $, _, _, _, $, _, $, _, $, _, $, _, _, _, $, _, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, $, _, $, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

static TileType arena[] =
    { $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $
    , $, _, _, _, _, _, _, _, _, _, h, _, _, _, _, _, $ 
    , $, _, $, T, $, _, $, $, $, $, $, _, $, T, $, _, $ 
    , $, _, $, _, _, _, h, _, _, _, h, _, _, _, $, _, $ 
    , $, _, $, _, $, $, $, $, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, _, _, _, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , _, _, $, _, $, _, $, _, B, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, _, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, $, $, $, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, _, _, _, _, _, $, _, $, _, $ 
    , $, _, $, _, $, _, $, $, $, $, $, $, $, _, $, _, $ 
    , $, _, $, _, _, _, h, _, _, _, h, _, _, _, $, _, $ 
    , $, v, $, T, $, _, $, $, $, $, $, _, $, T, $, v, $ 
    , $, _, _, _, _, _, h, _, _, _, _, _, _, _, _, _, $ 
    , $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $ 
    };

#undef $
#undef T
#undef S
#undef B
#undef _
#undef v
#undef h

/* TODO: general purpose growing array (like std::vector form STL) is needed */
extern void find_enemies( Map * const map )
{
    const size_t chunk_size = 8;
    const size_t element_size = sizeof( Enemy );
    size_t buffer_capacity = chunk_size;
    size_t found_count = 0;

    Enemy enemy;

    Enemy *buffer = malloc( element_size * buffer_capacity );
    if (buffer == NULL) return;

#define MAP_AT(x, y)\
    (map->data[(x) + map->width * (y)])

    for ( int i = 0; i < map->width; i++ ) {
        for ( int j = 0; j < map->height; j++ ) {
            const int tile = MAP_AT(i, j);
            
            if (tile != SPAWNER_V_ENEMY && tile != SPAWNER_H_ENEMY)
                continue;

            MAP_AT(i, j) = TILE_FLOOR;
            
            init_enemy( &enemy, i, j );
            if (tile == SPAWNER_H_ENEMY)
                enemy.flags |= ENEMY_MOVING_HORIZONTAL;
            /* growing buffer */
            if ( found_count >= buffer_capacity ) {
                buffer_capacity += chunk_size;
                buffer = realloc( buffer, element_size * buffer_capacity );
                if (buffer == NULL) return;
            }
            
            buffer[ found_count ] = enemy;
            found_count = found_count + 1;
        }
    }

#undef MAP_AT
    /* trim buffer and save it */
    buffer = realloc( buffer, element_size * found_count );
    if (buffer == NULL) return;
    
    map->inital_enemy_states = buffer;
    map->enemies_count = found_count;
}

extern TileType *pick_nonrandom( const int level )
{
    const int k = level / ( RANDOM_BETWEEN_COUNT + 1 );
    switch ( k ) {
        case 0:  return mess; 
        case 1:  return hello;
        case 2:  return sliders; 
        case 3:  return mutual_core; 
        case 4:  return floor_is_lava; 
        default: return arena; 
    }
}

